# Javascript Style Guide
---
В этом файле содержатися шпаргалка с правилами синтаксиса для большей читаемости и понятности кода.


## Синтаксис
![Syntax]
(https://learn.javascript.ru/article/coding-style/code-style.png)


### Пробелы между аргументами

**Хороший пример**
``` js
function sayHi(a, b) {
  ...
}
```

**`Плохой` пример**
```js
function sayHi(a,b) {
  ...
}
```

### Пробелы между знаком равно

**Хороший пример**
``` js
let element = [];
```

**Плохой `пример`**
``` js
let element=[];
```



### Фигурные скобки

Фигурные скобки пишутся на той же строке, так называемый "египетский стиль". Перед скобкой - пробел.

**Хороший пример**
``` js
if (n < 0) {
  alert('Значение ' + n + ' не поддерживается');
}
```

**Приемлимый пример, если строчка короткая**
``` js
if (n < 0) alert('Значение ' + n + ' не поддерживается');
```

**`Плохой` пример**
```js
if (n < 0) {alert('Значение ' + n + ' не поддерживается')};
```

### Длина строки
Не стоит делать слишком длинные строки. Как правило, длина составляет 80 - 120 символов.
Более длинные строки следует разбивать для лучшей читаемости.


### Отступы
Отступы нужны двух типов:
+ **Горизонтальный отступ**
``` js
show("Строки" +
     " выровнены" +
     " строго" +
     " одна под другой");
```

+ **Вертикальный отступ, для лучшей разбивки кода – перевод строки.**
``` js
function pow(x, n) {
  var result = 1;

  for (var i = 0; i < n; i++) {
    result *= x;
  }
 
  return result;
}
```
Не желательно иметь более 9 строк кода подряд без вертикального отступа.


### Точка с запятой
Точки с запятой нужно ставить, даже если их, казалось бы, можно пропустить.

В JavaScript перевод строки  заменяет точку с запятой, но лишь частично, поэтому лучше её ставить.


## Именование

Общее правило:
+ Имя переменной – существительное.
+ Имя функции – глагол или начинается с глагола.

Для имен, как правило, применяется английский язык (не транслит) в паре с camelCase.


## Уровни вложенности

Уровней вложенности должно быть немного. Лучше быстро обработать простые случаи, вернуть результат, а дальше разбираться со сложным, без дополнительного уровня вложенности.


## Функции = Комментарии

Функции должны быть небольшими. Если функция большая – желательно разбить её на несколько.
``` js
function showPrimes(n) {
  nextPrime: for (var i = 2; i < n; i++) {

    for (var j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // простое
  }
}
```

Лучше использовать дополнительную функцию isPrime(n)
``` js
function showPrimes(n) {

  for (var i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // простое
  }
}

function isPrime(n) {
  for (var i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
```


## Размещение функции под кодом

При чтении такого кода мы хотим знать в первую очередь, что он делает, а уже затем какие функции ему помогают. Если первым идёт код, то это как раз дает необходимую информацию. Что же касается функций, то вполне возможно нам и не понадобится их читать, особенно если они названы адекватно и то, что они делают, понятно из названия.

## Коментарии

+ **Плохие коментарии** - отвечающие на вопрос "что происходит в строке/коде?"
+ **Хорошие коментарии:**
  - Архитектурный комментарий – «как оно, вообще, устроено». Какие компоненты есть, какие технологии использованы, поток взаимодействия. О чём и зачем этот скрипт.
  - Справочный комментарий перед функцией – о том, что именно она делает, какие параметры принимает и что возвращает.






Здесь приведены основные принципы хорошего оформления кода, которые уместно применять как для себя, так и в больших проектах.

Используемая литература
(https://learn.javascript.ru/coding-style)


---
Javadcript Best Practices
---
Здесь приведены советы при написании хорошего, красивого javascript кода



### 1). Всегда объявлять локальные переменные.

Все переменные , используемые в функции должны быть объявлены как локальные переменные.

Локальные переменные должны быть объявлены с ключевым словом var, let или const.
В противном случае они станут глобальными переменными.

``` js
//global
value;

//local
var block = [];
let element = "";
const button = idElem;
```

Строгий режим не позволяет необъявленных переменных.



### 2). Объявления переменных в начале

Переменные объявляются в начале кода или функции.

Это дает возможность единого места поиска переменных, снижает возможность повторного объявления переменной и
делает код чище.

``` js
var firstName = "",
    lastName = "",
    price = 0,
    discount = 0,
    fullPrice = 0,
    myArray = [],
    myObject = {};

function sayHi ( name ) {
  alert( name + ", hi!" );
}
```



### 3). Инициализировать переменные.

В примере выше все переменные инициализированы при объявлении, это позволяет сразу определить тип используемых данных и избежать получения нежелательных неопределенных значений.



### 4). Объявлять число, строку или булево значение, как примитив.

Всегда рассматривать числа, строки или булевые значения как примитивные, не в качестве объекта.
Это позволяет увеличить скорость выполнения и не вызовет неприятных побочных явлений.

``` js
var x = "John";             
var y = new String("John");
(x === y) // false, так как х - string, y - object.
```



### 5). Не применять инициализацию через new.

+ Используйте {}вместоnew Object()
+ Используйте ""вместоnew String()
+ Используйте 0вместоnew Number()
+ Используйте falseвместоnew Boolean()
+ Используйте []вместоnew Array()
+ Используйте /()/вместоnew RegExp()
+ Используйте function (){}вместоnew Function()

``` js
var x1 = {};           // new object
var x2 = "";           // new primitive string
var x3 = 0;            // new primitive number
var x4 = false;        // new primitive boolean
var x5 = [];           // new array object
var x6 = /()/;         // new regexp object
var x7 = function(){}; // new function object
```



### 6). Применять строгое сравнение === вместо ==

  - ==Оператор сравнения всегда преобразует (к соответствию типов) перед сравнением.
  - ===Оператор силы Сравнение значений и типов:

``` js
0 == "";        // true
1 == "1";       // true
1 == true;      // true

0 === "";       // false
1 === "1";      // false
1 === true;     // false
```


### 7). Присвоение значения по умолчанию.

Хорошая практика присваивать значения по умолчанию, так как неопределенные значения undefined могут привести к поломке кода.

Например, если функция вызывается без аргумента:

``` js
function myFunction(x, y) {
  if (y === undefined) {
    y = 0; // при дальнейшем использовании у, его значение будет определенным 
  }
}
```


### 8). Устанавливать default значение в конструкции Sweetch.

``` js
switch (new Date().getDay()) {
  case 0:
    day = "Sunday";
    break;
  case 1:
    day = "Monday";
    break;
  case 2:
    day = "Tuesday";
    break;
  case 3:
    day = "Wednesday";
    break;
  case 4:
    day = "Thursday";
    break;
  case 5:
    day = "Friday";
    break;
  case 6:
    day = "Saturday";
    break;
  default:
    day = "Unknown";
}
```


### 9). Замена немедленно вызываемых функций (IIFE) на блоки (Blocks)

Обычно немедленно вызываемые функции используют для ограждения значений в их областях видимости. В ES6 можно создавать блочные области видимости.

``` js
(function () {
    var food = 'Meow Mix';
}());

console.log(food); // Reference Error
```
Пример Blocks
``` js
{
    let food = 'Meow Mix';
};

console.log(food); // Reference Error
```

Такая конструкция имеет более приятный вид, а главное выполняет поставленную задачу, скрыть значение переменной `food`.



### 10). Шаблонные литералы (ES6)

Шаблонные литералы поддерживают интерполяцию, что делает задачу конкатенации строк и значений:

```js
var name = 'Tiger';
var age = 13;

console.log('My cat is named ' + name + ' and is ' + age + ' years old.');
```
Гораздо проще:
``` js
const name = 'Tiger';
const age = 13;

console.log(`My cat is named ${name} and is ${age} years old.`);
```

Помимо всего, шаблонные литералы сохраняют перенос строк:
``` js
let text = ( `cat
dog
nickelodeon`
);
```


Этот список будет пополняться и расширяться.



